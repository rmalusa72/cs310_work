TO RUN: 
compile with "javac Triangulate.java"
run with "java Triangulate n (-p)"
ex. "java Triangulate 10" to calculate and print the number of triangulations of the 10-gon, 
	"java Triangulate 6 -p" to calculate and print the number + all triangulations of the hexagon

DISCUSSION
It seemed intuitive to me to build up the series of sets of triangulations one at a time, using the previous set of triangulations for the n-1 gon to find the set of triangulations for the n-gon by adding single ears/rotating/etc at each step, rather than starting with an n-gon and dividing it up. 

My first idea was to take every triangulation of the n-1-gon and affix an ear to each in the same location, between vertices 0 and 1. Because every triangulation of the n-gon has at least one ear, which can be rotated to point "up" in this configuration, the triangulations produced by this ear adding can be rotated to produce all triangulations of the n-gon — with some duplicates, as some of them have rotational symmetry or are rotated duplicates of each other to start, but many of these duplicates can be avoided by ceasing rotation when the rotated triangulation matches one previously found. I wanted to store each triangulation as a list of lists of numbers, where the outer list contained a list corresponding to each vertex, and each inner list contained numbers corresponding to the labels of each vertex that vertex was connected to. In order to facilitate fast comparison, I wanted those numbers to be sorted, but when the polygon was rotated, the labels of the vertices would change and the sorting would be disrupted. However, I realized they were still mostly in order, as every entry had been changed by the same amount, and ended up implementing both inner and outer lists as cyclic doubly-linked lists to make rotation and re-orienting to restore sorting easier. This meant all my operations on individual triangulations were fairly fast (mostly O(n), where n was the number of vertices).

At first, I was adding triangulations to an ArrayList as they were found, but since it was necessary to check for duplicates, this was very slow (the whole process was O(n^2), where n was the (very large) number of triangulations). Ordering triangulations was not something I initially thought of, because it is not intuitive to say which triangulation of a pair is less than or greater than the other one, but I eventually implemented an ordering so that I could store the triangulations in a TreeSet and reduce the complexity of adding to O(logn). This sped things up significantly, but immediately I ran into space issues, where the heap ran out of space between the 16-gon and the 17-gon. 

In order to save space, I re-implemented the Triangulation class to use arrays of arrays of integers instead of linked lists of linked lists of integers. This made rotation impractical, so instead of adding an ear to the "top" of each triangulation and then rotating it, I added an ear between each pair of vertices (except the last — since every triangulation of the n-gon has at least *two* ears, we can ignore one ear possibility, as all the triangulations it produces must have already been produced by the other ear locations). I removed the triangulations of the n-1-gon from their TreeSet as they were considered, which saved some space, and then replaced the integers with bytes, as the vertex labels required only 5 bits of space. I tried implementing tiny 5-bit numbers with arrays of booleans, but learned that booleans in Java are actually very large; then I tried to pack the sets of 5 bits into bytes, using all the space available so that one number took up the first five bits of a byte and the next took up the last three bits of that byte and the first two bits of the next, but I had difficulty with the implementation. 

The furthest I got with this method is the number of triangulations of the 17-gon, 9694845. This was accomplished quickly, in a minute and eleven seconds on the Powerpuff server, but then the heap ran out of space approximately 3.2 million triangulations into the 18-gon. 

It occurred to me to write the set of triangulations at each step to a file, since I only needed to access them one at a time and then I would save heap space by reading them in one by one. Then I realized that I did not actually need to compare new triangulations against previously generated triangulations to eliminate duplicates — essentially, if a triangulation was created by, ex., inserting an ear at vertex 3, and it had an ear at vertex 1 or 2, it would have already been generated by those passes — so I read and wrote both the previous set of triangulations and the new set of triangulations one at a time. This was acceptably fast using a BufferedWriter and a BufferedReader, and got further into the triangulations of the 18-gon (anywhere from 14 to 21 million), but quickly ate up my whole disk space quota on the CS server without actually finishing the 18-gon. Because it doesn't actually get to n=18, and because filling the user's whole disk space with huge files seems like bad etiquette, I have included the version discussed above instead, which does not write to a file. 